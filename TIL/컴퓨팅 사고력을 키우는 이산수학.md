[TOC]



# Ch13. 알고리즘

### 13.1 알고리즘의 개념

- 알고리즘 : 문제 해결을 위한 체계적 단계

### 13.2 알고리즘의 효율성

- 하드웨어 성능 증가로 공간복잡도 보다 시간복잡도(프로그램이 수행되는 시간)가 중요

- Big-O 표기법

- ``` 
  f(n) = O(g(n))
  ```

- 함수 f(n)은 g(n)의 차수이며 이 복잡도 f(n)은 모든 **자연수 n** 을 입력으로 하는 알고리즘이 수행될 때 그 수행시간이 `f(n) <= c * g(n)` 가 되는 **양의 정수** c와 n이 존재하면 성립하는 공식

- 알고리즘이 n개의 입력으로 수행될 때, 그 수행시간이 |g(n)| 에 양의 정수 c를 곱한 것보다 작거나 같은지를 확인한다.



#### ⭐️ 알고리즘의 복잡도 => 연산 수행 횟수로 파악한다.

```
연산 수행 횟수 = 산술연산 + 출력문 + return 문 수행 횟수
```

❗️선언문, 초기화문, 조건문, 반복문을 제외한 순수한 실행문만을 계산한다.



### 다양한 알고리즘

#### 1. 유클리드 알고리즘(Euclid Algorithm: GCD(a, b))

두 양의 정수 a, b 가 갖는 공약수 중 최대공약수를 찾는 알고리즘.

[ 구현 ]

```python
# a > b 일 때, 두 양의 정수 a, b의 최대공약수를 구한다.
# 양의 정수 k, r은 a를 b로 나눈 나머지이다.
# GCD(a, b) = GCD(b, r)

def algorithmn_gcd(a, b):
    if a < b:
        tmp = a
        a = b
        b = tmp

    while b != 0:
        r = a % b
        a = b
        b = r

    return a
```

[ 시간복잡도 ]

f(n) = 3n + 4 <= 3n + 4n <= 7n 이므로

n >=1 일때, c=7 이고 시간복잡도는 O(n)이다.



#### 2. 재귀 알고리즘(Recursive Algorithm)

문제를 해결하면서 어떤 항목이 자기 자신을 다시 호출해 사용하는 방법

[ 구현 ]

f(0) = 1

f(n) = 1 + f(n-1), n >= 1

```python
# f(n) = n + 1 이 된다.
# 반복문 구현
def sum(n):
  s = 0
  for i in range(n+1):
    s = s + 1
  
  return s
```

```python
# 재귀 구현
def sum(n):
  if n != 0:
    return sum(n-1) + 1
  else:
    return 1
```

[ 시간복잡도 ]

n+1 번 덧셈연산 + return 문 1 

T(n) = n + 2 <= n + n = 2n

따라서 시간복잡도는 O(n)이다.

