21.12.31 

해시맵 공부하다가 HashMap은 Hashtable의 신버젼으로 동기화 처리가 되어있지 않다. => 가 이해되지 않아 여기까지 오게 되었다. 재밌다.

[TOC]

# 멀티쓰레드란?

- 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행능력을 향상시키는 것이다.
- 하나의 프로그램이 동시에 여러 개의 일을 수행할 수 있도록 한다.



# 멀티쓰레드를 사용하는 이유?

- 멀티프로세스보다 하나의 프로세스에서 여러 쓰레드로 나누어 수행하므로
  - 메모리 공간과 자원 소모가 적다. 쓰레드 간 통신이 필요한 경우 `전역 변수 공간` 또는 동적으로 할당된 공간인 `heap` 영역을 이용하여 데이터를 주고받을 수 있다.
  - 쓰레드 문맥교환은 프로세스의 문맥교환과 달리 `캐시 메모리` 를 비울 필요가 없어 더 빠르다.



# 멀티프로세스와 멀티쓰레드의 차이점

- 멀티프로세스 : [데이터, 힙, 스택] 영역 모두를 비공유
- 멀티쓰레드 : [데이터, 힙]은 공유, [스택] 영역만 비공유



# 멀티쓰레딩의 장점

- 생성 및 컨텍스트 스위칭이 멀티프로세스보다 빠르다.
- 데이터와 힙 영역을 공유하기 때문에 여기로 데이터 교환이 가능하다.



# 멀티쓰레딩의 단점

- 멀티프로세스 기반에서는 프로세스 간 공유하는 자원이 없기 때문에, 동일한 자원에 대해 접근할 일이 없지만 멀티쓰레딩을 기반으로 프로그래밍 할 때는 서로 다른 쓰레드가 데이터와 힙 영역을 공유하기 때문에 다른 쓰레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.
- 따라서 멀티쓰레딩 환경에서는 `동기화 작업` 이 필요하다.



# 동기화란?

동기화란 시스템의 한정적인 자원에 여러 쓰레드가 접근하여 사용하려고 할 때, 문제가 발생할 수 있어 이를 방지하기 위해 **"쓰레드들에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정해주는 기법"** 이다.



동기화를 통해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤한다.

하지만 이로 인해 `병목 현상` 이 발생하여 성능이 저하될 수 있다. 

따라서 과도한 락(lock) 으로 인한 병목 현상을 줄여야 한다.

**어떻게?**

공유 자원이 아닌 부분은 동기화 처리가 필요 없으므로, 동기화 처리가 필요한 부분에만 `synchronized` 키워드를 통해 동기화한다. 

불필요한 부분까지 동기화하면 현재 쓰레드는 락(lock)을 획득한 쓰레드가 종료하기 전까지 대기해야 하기 때문이다.



# 임계 영역(Critical Section)

둘 이상의 쓰레드(또는 프로세스)가 공유 자원에 동시에 접근하면 문제가 발생할 수 있다.

이런 문제를 일으킬 수 있는 코드 블록을 임계 영역이라 한다. 즉, 임계 영역은 배타적 접근 권한이 요구되는 공유 리소스(전역변수, static변수) 에 접근하는 코드 블록이다.



# 동기화 방법

동기화를 통해 쓰레드에게 처리권한을 주거나 순서를 조정한다고 했는데 어떤 방법이 있을까.



## 상호 배제를 이용한 뮤텍스와 모니터

### 상호배제란?

"한 프로세스가 공유 자원을 접근하는 임계 영역 코드를 수행하고 있으면 다른 프로세스는 공유자원을 접근하는 임계 영역 코드를 수행할 수 없다" 는 조건



### 1. 뮤텍스

뮤텍스는 `Mutual Exclusion` 의 약자로, 임계 영역에 들어가기 위해서는 이 뮤텍스 객체를 가지고 있어야만 한다. 

임계 영역에 들어간 쓰레드는 뮤텍스를 이용해 임계영역에서 본인이 나올 때 까지 내부에서 잠근다.

<img src="[운영체제] 멀티쓰레드.assets/14.jpg">

임계 영역에 진입하길 원하는 3개의 쓰레드가 있다.

<img src="[운영체제] 멀티쓰레드.assets/16.jpg">

한 쓰레드가 뮤텍스를 획득하고 진입한 쓰레드는 임계영역을 처리한다. 다른 쓰레드들은 아무 일도 못하고 쉬게 된다(BLOCK 상태)

<img src="[운영체제] 멀티쓰레드.assets/17.jpg">

임계영역에 있던 쓰레드가 빠져나와 뮤텍스를 반환했다. 쉬던 쓰레드들이 뮤텍스를 가질 수 있다. 이 쓰레드들 중 하나가 뮤텍스를 가지게 된다. 지금까지의 과정을 반복한다.

##### 뮤텍스 기반의 동기화 기법

-  먼저 CreateMutex() 함수로 뮤텍스를 생성한다.
- WaitForSingleObject() 함수로 뮤텍스는 한 쓰레드만 가질 수 있다. 이 함수는 signaled 상태의 커널 오브젝트를 반환할 경우, 해당 커널 오브젝트를 non-signaled 상태로 변경해버린다. 결국 한 쓰레드가 뮤텍스를 획득하자마자 뮤텍스커널 오브젝트 상태는 non-signaled 상태가 되기 때문에 다른 쓰레드들은 뮤텍스를 가질 수 없다. 이 때문에 하나의 쓰레드만 임계영역에 진입할 수 있다.
- 임계영역을 빠져나온 쓰레드는 뮤텍스를 반납해야 한다. 그래야지 다른 쓰레드가 뮤텍스를 얻어 임계영역에 접근할 수 있다. 이를 위해 ReleaseMutex() 함수를 호출한다.
- 그리고 뮤텍스 리소스를 반납한다.



### 2. 모니터

모니터는 Mutex(Lock)과 Condition Variables(Queue) 를 가지고 있는 Synchronization 매커니즘이다. 

예를 들어, 자바에서 모든 객체는 Object 클래스를 상속 받는다. 이 오브젝트 클래스는 `wait()`, `notifyAll()` , `notify()` 메서드를 가지고 있는게 이것이 `Condition Variables` 역할을 한다.

즉, 모든 자바의 객체는 Monitor를 가지고 있으며 자바에서는 Mutual Exclusion 해결을 위한 구현체로 `Synchronization` 키워드가 있다. 예를 들어, 싱크로나이젼이 메서드에 선언되어 있고 쓰레드 A가 이미 Lock을 획득하여 임계 영역을 수행중이라고 가정하자. 쓰레드 B가 동일 메서드를 수행하기 위해 Lock 이 반환 될 때 까지 대기하는데, 이때 모니터를 사용한다.



### 3. 세마포어



# 자바에서의 동기화

## 자바 런타임 데이터 영역과 공유데이터

쓰레드간 공유하는 영역을 확인하여 동기화 처리 해야한다.

영역은 다음과 같다.

1. **PC(Program Counter) 레지스터 영역:** 스레드 각각이 갖고 있으므로 스레드간 독립적인 영역
2. **JVM 스택 영역:** 지역변수, 파라미터, 리턴값, 객체 레퍼런스들이 저장되어 있는 공간. 스레드 각각이 갖고있는 따로 관리되는 독립적인 영역
3. **힙 영역:** 생성된 자바의 객체들이 저장되는 부분. 모든 스레드들이 접근 가능한 공유되는 영역.
4. **메소드 영역:** 함수영역으로 각 클래스 또는 인터페이스에 런타임 컨텍스트 풀영역, 메소드 생성자를 저장하는 영역으로 모든 스레드에 의해서 공유되는 영역.
5. **런타임 컨텍스트 풀 영역:** 클래스 또는 인터페이스의 클래스변수, 스태틱변수, 클래스 객체의 레퍼런스를 저장하는 영역으로 스레드들간 공유되는 영역.
6. **데이터와 메소드 스택 영역:** 마찬가지로 스레드들간 공유되는 영역.



힙 영역, 메소드 영역, 런타임 컨텍스트 풀 영역 확인

### lock, monitor, synchronized

- 자바는 모든 객체에 `lock`을 포함시킨다.
- `lock`은 모든 객체가 인스턴스화될 때, 힙 영역에 객체가 저장될 때 자동으로 생성된다.
- `lock`은 보통 사용되지 않으며 동기화가 필요한 부분에서 `synchronized` 키워드를 사용한다. (메서드 또는 블럭 선언)
- 싱크로나이즈드 키워드를 사용하여 해당 객체의 락을 검사하며, 락의 현재 사용 여부를 검사함으로써 각 객체를 보호한다.
