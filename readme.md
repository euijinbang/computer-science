# STEPS

STEP1. 1.이산수학, 2.자료구조, 3.알고리즘

STEP2. 4. 네트워크, 5.운영체제, 6.컴퓨터구조

STEP3. 7.오토마타, 8.형식언어, 9.컴파일러, 10.데이터베이스



# 이산수학

|BOOK| 컴퓨터 사고력을 키우는 이산수학

|VOD| 공학 >컴퓨터ㆍ통신 >컴퓨터공학 | [이산수학] 가톨릭대학교 황병연



### 개요(0422)

- 이산수학(Discrete Mathmatics) : 연속적인 개념을 사용하지 않고 이산적인 수학 구조에 대해 연구하는 학문으로, 이산적인 대상물들을 분석하여 응용의 기반으로 삼는 학문이다. 예를 들어 디지털 시계는 이산적, 아날로그 시계는 연속적인 개념이다.
- 수학적 모델링
  - 1. 주어진 문제의 상황과 배경을 이해
    2. 주어진 문제의 수학적 구조와의 매핑  - 어떤 자료구조를 쓸 것인가? + 수학적 개념
    3. 수학적 기초 개념을 이용한 문제 해결



### 논리와 명제(0422)

- 명제란? 객관적인 기준으로 진릿값(참 또는 거짓)을 구분할 수 있는 문장이나 수식.

- 논리 연산 6가지
  - 부정(NOT)
  - 논리곱(AND) : 둘 다 참이어야 참
  - 논리합(OR) : 둘 다 거짓이어야 거짓
  - 배타적 논리합(XOR) : 진릿값 둘 중 하나만 참일 때 참
  - 조건(p -> q) : 둘다 참이거나 가정이 F이면 참
  - 쌍방 조건 (p<->q) : p, q가 둘 다 참이거나 둘 다 거짓이면 참
- 역, 이 대우 : 조건명제와 대우의 진리값은 같다.
- 논리적 동치 : 두 개의 합성명제 P와 Q의 진릿값이 같은 경우
- 한정자
  - 전체한정자
    - 모든 원소에 대해 그 명제가 참이면 그 명제함수도 참이다.
    - 원소 중 하나라도 명제가 거짓이면 명제함수는 거짓이다.
  - 존재한정자
    - 원소들 중 하나라도 명제함수를 참으로 하는 원소가 있다면 명제함수도 참이다.
    - 모든 함수에 대해 그 명제가 거짓이면 그 명제함수는 거짓이다.
  - **부정
    - "이 상자에 있는 모든 과일은 사과이다." 부정 | "이 상자에 있는 어떤 과일은 사과가 아니다."
    - "이 상자에 있는 어떤 과일은 사과이다." 부정 | "이 상자에 있는 모든 과일은 사과가 아니다."
- 추론
  - 논리적 추론 : 참(T)인 명제를 근거로 하여 다른 명제가 참(T)임을 유도하는 방식



### 그래프(0421)

- 개념 
  - 그래프 G는 꼭짓점 집합 V와 변 집합 E로 구성된다.
  - 형태 : 다중그래프, 방향그래프, 가중치그래프
  - 차수 : 꼭지점 v에 근접하는 변의 수
- 종류
  - 부분그래프와 부분 신장 그래프(Spanning Graph) : 부분 신장 그래프는 그래프 G의 꼭짓점을 모두 포함하지만 변은 일부만 포함하는 그래프입니다.
  - 동형 그래프
  - 평명 그래프(Planar Graph) 와 오일러 공식
  - 연결 그래프 : 그래프를 구성하는 모든 꼭짓점 사이에 경로가 존재하는 그래프입니다.
  - 이분 그래프(Bipartite Graph) 
- 표현
  - 인접행렬
  - 인접리스트 : 그래프 G=(V, E)를 구성하는 각 꼭짓점에 인접하는 꼭짓점들을 연결리스트로 표현한 것입니다.
- 오일러와 해밀턴
  - 오일러 경로와 오일러 그래프 : 그래프의 모든 변을 한 번씩만 지나는 경로입니다.
  - 해밀턴 경로와 해밀턴 그래프 : 그래프의 모든 꼭짓점을 한 번씩만 지나는 경로입니다. 
- 그래프의 활용
  - 최단 경로 문제
    - 다익스트라 알고리즘 : 특정 노드에서 다른 노드들 까지의 각각의 최소 거리를 구하는 알고리즘입니다.
    - 순회판매원 문제(해밀턴 순회 응용): 방문해야 할 도시들과 이들 사이의 거리가 주어질 때, 판매원이 특정 도시에서 출발하여 어떠한 도시도 두 번 방문하지 않고 모든 도시를 거쳐 처음 출발한 도시로 돌아올 때, 총 여행 거리가 최소가 되는 경로 => 가장 가까운 거리의 도시를 고르는 그리디 알고리즘. 최소가 아닌 '최적'의 경로를 구하는 것입니다. (nearest-neighbor 최근점 이웃 방법)
  - 그래프 탐색
    - 깊이 우선 탐색
    - 너비 우선 탐색
- 그래프와 색칠 문제 : 4색 문제 - 평면을 유한 개의 부분으로 나누어 각 부분에 색을 칠할 때, 서로 맞닿은 부분을 다른 색으로 칠한다면 최대 4가지 색으로 충분합니다. 지도를 생각해봤을 때, 특정 국가를 둘러싼 나라가 짝수 개라면 3가지 색, 홀수 개면 4가지 색이 필요합니다.



### 트리(0429)

- 트리란 : 루트라는 특별한 노드를 가진 비순환 연결그래프

- 용어

  - root
  - degree 차수
  - leaf node : 차수가 0인 노드
  - children ndoe : 어떤 노드의 서브 트리의 루트노드
  - parent node
  - sibling node : 동일한 부모를 가지는 노드

  - level
  - height == maximum level

- **노드와 엣지의 관계  : G(V, E), |V| = n, |E| = m 일 때 n = m-1**
- **어느 한 연결선만 추가해도 사이클이 생긴다.**

```
# n-array tree : 중간 노드가 최대 n개의 자식 노드를 가지는 때
# n = 2인 경우를 binary tree라 한다.
```

- 이진 트리 : 트리 최대 차수가 2 이하인 트리
  - 이진 트리에서 leaf node 의 갯수 = 차수가 2인 노드의 갯수 + 1
- 편향 이진트리(skewed binary tree)
- 완전 이진 트리(complete binary tree) : 높이가 h일 때 레벨 0부터 h-1까지의 모든 부모 노드의 차수가 2차이고, 레벨 h는 왼쪽부터 노드가 채워져 있는 트리
- 포화 이진 트리(full binary tree)
- 이진 트리의 구현
  - 배열로 구현
    - 부모 노드의 인덱스가 n일 때, 왼쪽 자식 노드의 인덱스 2n, 오른쪽 자식 노드의 인덱스 2n+1
    - 자식 노드의 인덱스가 n일 때, 부모 노드의 인덱스 n//2
  - 연결리스트로 구현
    - 배열로 구현할 때의 메모리 낭비를 해결
- 트리의 순회
  - L 다음 R이 와야한다 
  - preorder (DLR) / inorder (LDR) / postorder (LRD)
- 이진 탐색 트리
  - 규칙
    - 트리에서 탐색되는 모든 원소는 서로 다른 유일키를 갖는다.
    - 왼쪽 서브트리에 있는 원소들의 키는 그 루트의 키보다 작거나 앞선 순서를 갖는다.
    - 오른쪽 서브트리에 있는 원소들의 키는 그 루트의 키보다 크거나 뒤의 순서를 갖는다.





# 자료구조

|BOOK| 파이썬으로 배우는 자료 구조 핵심 원리

|VOD| 공학 >컴퓨터ㆍ통신 >컴퓨터공학 | [자료구조] 건국대학교 남원홍



### 개요(0423)

- 데이터형 Data Types , 변수들이 가질 수 있는 값의 종류
  - primitive & user data type
- 데이터 구조 Data Structures
  - 선형 : 연결리스트, 스택, 큐
  - 비선형 : 트리, 그래프
- 추상 데이터형  Abstract Data Type
  - 문제를 푸는 과정을 단순화시키기 위해 데이터 구조와 연산을 합쳐 놓은 것
  - 구현 레벨을 생각하지 않고 상위 레벨에서만 생각하는 것
  - C++, Java (OOP) 학생 데이터 타입이라면 공부하기, 수강신청하기 등 행위까지 포함
  - 리스트, 스택, 큐, 우선순위 큐, 이진트리, 집합, 해시테이블, 그래프 등
- 왜 알고리즘을 분석하는가?
  - 한 가지 문제를 푸는 데 여러 가지 알고리즘이 있을 수 있다.
  - 알고리즘 분석은 시간과 공간적으로 어느 것이 가장 효율적인지 알 수 있게 해준다.
- 수행 시간 분석
  - 문제의 크기(입력의 크기 n)이 증가함에 따라 처리 시간이 얼마나 증가하는지를 분석한다.
  - 증가율 : 함수의 입력의 크기가 증가함에 따라 수행 시간이 증가하는 비율
- 분석의 종류
  - 알고리즘은 어떤 입력이냐에 따라 수행시간이 달라진다
  - 최선의 경우 vs. 최악의 경우 vs. 평균
  - Big-O notation



### 재귀와 백트래킹(0423)

- 자기 자신을 호출하는 함수를 recursion 이라 한다.
- 재귀적 알고리즘에는 두 가지 경우, 재귀적 경우(recursion case)와 기본 경우(base case)가 있다.
- ""더 작은 문제""를 풀게 하는 것이며 작은문제는 결국 수렴해야 한다.(base case)

- 재귀의 경우 메모리에 스택프레임 공간이 필요하다.
- 무한 재귀에 들어가면 메모리 용량을 초과해서 stack overflow를 초래한다. (힙영역, malloc 부분과 만나면 OS가 강제종료시킨다.)
- 무한 루프(while)은 추가적인 메모리가 필요한것은 아니므로 위의 문제를 초래하진 않는다.

![image-50px](readme.assets/IMG_3016.JPG)

![IMG_3016](readme.assets/IMG_3018.JPG)



### 연결리스트(0424)

![IMG_3020](readme.assets/IMG_3020.JPG)

- 리스트는? 순서가 있는 데이터의 집합
- Array vs. Linked List 각각의 장단점 파악
- 배열의 장점
  - 간단하고 사용하기 쉽다.
  - 항목에의 접근이 더 빠른다.
  - 메모리 안에서 특수한 locality가 있다.
    - 배열은 연속된 메모리 목록이므로 배열의 항목들은 물리적으로 근처에 위치
    - 이것은 현대의 CPU 캐싱 기법에 매우 유리하다.
- 배열의 단점
  - 고정된 크기. 배열의 크기는 정적이다. 실행 시간에 변경 불가.
  - 특정 위치에 항목을 삽입하려면 다 밀어야 하므로 시간이 오래 걸린다.
- 동적 배열
  - 실행 시간에 Array의 사이즈를 늘리고 줄일 수 있는 배열이다.
  - 배열이 다 차면 원래 배열의 2배 크기의 새 배열을 만든다.
  - 배열의 항목 수가 절반 이하가 되면 배열 크기를 반으로 줄인다.
- 연결리스트의 장점
  - 메모리 공간을 낭비하지 않는다.
  - 상수 시간 안에 확장이 가능하다.
- 연결리스트의 단접
  - 개별 항목에 접근하는 시간이 길다. 배열이 O(1)이라면 연결리스트는 최악의 경우 O(n)
  - 추가적인 참조 포인터를 위한 메모리 공간이 낭비
- 정적 vs 동적? 프로그램 실행전에 결정되면 static array, 실행시간에 변하면 dynamic array

![IMG_3021](readme.assets/IMG_3021.JPG)

- 연결리스트 ADT

![IMG_3023](readme.assets/IMG_3023.JPG)

![IMG_3025](readme.assets/IMG_3025.JPG)

- 연결리스트 풀어볼 문제 (https://programmers.co.kr/learn/courses/30/lessons/81303)



### 스택(0424)

- 스택이란? 데이터를 저장하기 위해 사용되는 간단한 데이터 구조
  - 삽입과 삭제가 한쪽 끝에서 이루어지는 순서가 매겨진 리스트이다.
  - 이 끝을 탑(TOP) 이라고 부른다.
  - 제일 마지막에 추가된 항목이 제일 먼저 삭제된다. (Last In First Out, LIFO)
- 변화
  - **스택에 항목이 삽입되는 것을 푸시(push) 라고 한다.**
  - **항목이 스택으로부터 삭제되는 것을 팝(pop) 이라고 한다.**
  - 빈 스택으로부터 항목을 팝하려는 것을 언더플로우(underflow)라고 한다.
  - 가득찬 스택에 항목을 푸시하려는 것을 오버플로우(overflow)라고 한다.

- 직접적인 적용 사례

  - 괄호 짝 맞추기

  - infix 를 postfix 로 바꾸기

  - postfix 수식 계산하기

  - 함수 호출 구현하기(재귀 포함)

  - 웹 브라우저에서 방문한 페이지로 돌아가기

    

### 그래프(0421)

- 개념

  - 방향 그래프 vs. 무방향 그래프

  - 방향이 있고 사이클이 없는 그래프 = 트리

- 표현

  - 인접리스트 : 정점 v에 연결된 모든 정점을 연결리스트로 표현.
    - 장점 : sparse한 그래프의 경우 인접행렬(V^2)보다 공간 낭비가 적다.
    - 단점 : 노드를 삭제하면 다른 노드의 연결리스트의 노드도 삭제해야 한다. 속도 측면에서 인접행렬보다 느리다.

- 최단경로 알고리즘

  - Unweighted graph 의 shortest path -> BFS
    - 수행시간 : 인접리스트 사용시 O(E + V) : for loop 에서는 주어진 정점으로 부터 나가는 간선을 검사하고  while loop 안에서 검사된 모든 간선의 합은 총 간선의 수와 같으므로 O(E)이다. 인접행렬을 사용했다면 복잡도는 O(V^2) 이다. 주어진 정점에 인접한 정점을 찾기 위해 길이가 V인 행렬의 한 행 전체를 읽어야 하기 때문이다.
  - Weighted grapth - Dijkstra algorithm -> BFS의 일반화
    - 현재 노드에서 가장 짧은 거리의 노드 찾는법 -> Priority Queue
    - 음수 간선을 처리할 수 없다.

- MST(Minimun Spanning Tree)

  - 사이클이 없는 연결된 그래프 + 무방향 그래프 + 가중치 그래프
  - 크루스칼 알고리즘

  ```
  V(정점) 의 서로 다른 트리로 시작한다. 모든 노드 다 돌거나 또는 edge가 V-1 개면 for loop 끊고 종료해도 된다.
  - MST를 만드는 동안 매번 최소 weight를 가진 edge를 선택해서(우선순위큐), 그 edge가 사이클을 만들지 않는다면 트리에 추가한다.
  - 처음에는 |V|개의 노드가 각각 트리로 존재한다.
  - 이때, edge를 하나 추가하면 두 개의 트리가 하나로 합쳐진다.
  - 알고리즘이 종료하면 오직 하나의 트리만 남는데, 이것이 MST 이다.
  ```

  크루스칼 알고리즘을 구현하는 두 가지 방법.

  1. Disjoint set의 UNION, FIND연산

     - 각 노드는 각각의 집합으로 시작해서
     - 매번 두 정점의 각각의 집합을 찾는다(FIND)  FIND(B) = FIND(C)?
     - 둘의 집합이 같으면 연결했을때 사이클이 생길테니까 Spanning Tree에 넣지않는다.
     - 둘의 집합이 다르면 Spanning 트리에 넣고 UNION으로 집합을 합친다.

     

  2. Priority Queue를 사용하여 weight를 priority queue 안에 유지

     - edge를 작은 순으로 쫙 넣는다.

  

  - 프림 알고리즘
    - 크루스칼과 다르게 시작점이 정해진다. 하나의 트리에서 시작해서 트리를 늘려나간다.
    - BSF처럼 가는데 다음에 갈 노드를 보고(큐에서 꺼낸 현재 노드), 그 노드로 가는 길들 중에 가장 weight이 작은 길을 선택한다.
    - 어디서 시작하던 같은 결과가 나온다.




### 트리(0429)

- 트리의 크기 구하기

- 트리의 높이 구하기

- 주어진 노드들의 최대 조상 구하기

- 트리순회 - 재귀함수 stack 공간을 생각하면...

  - skew tree 의 공간복잡도는 이진트리의 최악의 경우 O(n)
  - 포화이진트리의 공간복잡도는 O(log n)

- **Binary Search Tree 이진 검색 트리**

  - **Binary Tree의 경우 O(n), Binary Search Tree 는 O(logn)**
    - 편향트리일때 노드 갯수만큼 찾아야 하기 때문에
    - BST는 BT에 추가적으로 데이터의 제한을 두었다고 생각하면 된다!
  - 어떤 노드가 가질 수 있는 데이터 종류에 제한을 주므로 검색 연산의 일반적인 복잡도는 O(log n ) 이다.
  - 주 연산
    - 이진 검색 트리의 항목 찾기
    - 새 항목 삽입하기
    - 항목 삭제하기
  - **루트 데이터가 항상 왼쪽 서브트리 데이터와 오른쪽 서브트리 데이터 사이에 있기 떄문에 중위탐색을 수행하면 정렬된 리스트가 만들어진다. inorder traversal 시 정렬된다.**
  - 대부분.. 크기에 관련되어 있을 경우 왼쪽 서브트리를 처리하고, 루트를 처리하고, 오른쪽 서브트리를 처리한다.
  - **재귀적으로 구현시 worst case 시간복잡도 O(n), 공간복잡도 O(n)**
  - **비재귀적으로 구현시 worst case 시간복잡도 O(n), 공간복잡도 O(1)**




### 우선순위 큐(Priority Queue)(0503)

- 여러 개의 항목 중에서 최소 또는 최댓값을 찾을 때 사용한다.
- 최소항목을 리턴 및 삭제
- 최대항목을 리턴 및 삭제
- 먼저 들어온 것이 먼저 처리되지 않고, 정해진 우선순위에 따라 처리되는 작업 스케줄링이 Priority Queue이다. 
- 작은 키 값을 갖는 항목일수록 높은 우선순위를 가지는 Priority Queue를 Ascending Priority Queue라고 한다. (오름차순 우선순위 큐)
- 큰 키 값을 갖는 항목일수록 높은 우선순위를 가지는 Priority Queue를 Descending Priority Queue라고 한다. (내림차순 우선순위 큐)
- 주요 연산
  - Insert : key에 따른 데이터를 Priority Queue에 삽입한다. 항목들은 키에 따라 적용된다.
  - DeleteMin / DeleteMax : 가장 큰/작은 키를 갖는 항목을 삭제하고 리턴한다.
  - GetMin / GetMax : 가장 큰/작은 키를 가진 항목을 삭제하지 않고 리턴한다.
- 보조 연산
  - k-th smallest / k-th Largest : k번째로 작거나/큰 키를 리턴한다.
  - size : pq 안의 항목의 개수를 리턴한다.
  - heap sort : pq안의 항목을 우선순위(키)에 따라 정렬한다.
- 적용 사례
  - 데이터 압축 : 허프만(Huffman) 코딩 알고리즘 (알집)
  - 최단 거리 알고리즘 : 다익스트라 알고리즘 (네비게이션)
  - 최소 신장 트리 알고리즘 : 프림 알고리즘
  - 이벤트 지향 시뮬레이션 : 줄 서 있는 고객들
  - 선택 문제 : k번째 작은 항목 찾기

- 구현

  - 정렬되지 않은 배열 구현 [30, 10, 97, 5, 7, 15]

    - 삽입은 정렬하지 않고 넣고, 꺼낼때는 가장 작은 것을 꺼낸다.
    - 삽입 복잡도 O(1), 삭제 복잡도 O(n)

  - 정렬되지 않은 (연결)리스트 구현

    - 배열대신 연결리스트 사용
    - 삽입 복잡도 O(1), 삭제 복잡도 O(n)

  - 정렬된 배열 구현

    - 항목들을 키값에 따라 정렬하여 배열에 삽입, 삭제는 한쪽 끝에서만 수행한다.
    - 삽입 복잡도 O(n), 삭제 복잡도 O(1) - shift안한다는 가정

  - 정렬된 리스트 구현

    - 항목들을 키값에 따라 정렬하여 배열에 삽입, 삭제는 한쪽 끝에서만 수행한다.
    - 삽입 복잡도 O(n), 삭제 복잡도 O(1)

  - 이진 검색 트리 구현

    - 삽입이 무작위적이라면 평균적으로 삽입, 삭제 모두 O(log n)

  - 균형 이진 검색 트리 구현

    - 최악의 경우여도 삽입, 삭제 모두 O(log n)

  - 이진 힙 구현

    - 검색, 삽입, 삭제에 O(log n) 

    - 최솟값, 최댓값 찾기에 O(1)

       

### Heap과 Binary Heap(0503)

- 힙이란? 몇 가지 특수한 속성을 가진 트리
- **힙 속성 "노드의 값이 그 자식 노드의 값보다 작거나 같다. 또는 크거나 같다"**
- 트리의 높이 h > 0일때 모든 노드들은 h 또는 h-1 레벨에 있어야 한다. (완전이진트리)
- **즉, 힙은 완전 이진 트리여야 한다.**
- 힙의 종류
  - **Min Heap (최소힙) : 노드의 값이 자식 노드의 값보다 작거나 같아야한다.**
  - **Max Heap (최대힙) : 노드의 값이 자식 노드의 값보다 크거나 같아야 한다.**

- **힙은 다 이진 힙 @@@ Binary Heap @@@** 각 노드는 최대 두 개의 자식노드를 가진다.

  - 힙은 내부를 '배열'로 만든다.

- 노드의 부모

  - **i번째 위치의 노드에서 부모 노드는 (i-1)/2 을 버림한 위치에 있어야 한다. (floor)**

  - ```c
    int Parent(struct Heap *h, int i) {
    	if (i <= 0 || i >= h -> count)
    			return -1;
      return (i-1)/2;
    }
    ```

  - 시간 복잡도 O(1)![IMG_3047](readme.assets/IMG_3047.JPG)

- 노드의 자식

  - **노드의 부모가 i번째일 때, 자식은 (2*i) + 1, (2*i) + 2**

  ![IMG_3048](readme.assets/IMG_3048.JPG)

- 노드 삽입

  ![IMG_3050](readme.assets/IMG_3050.JPG)

  - 항목 i를 힙으로 만들기 위해 자식 중 최대 값을 찾아 바꿔치기한다.
  - `percolate down`
  - 다른 쪽은............
  - 양 쪽 sub tree가 반드시 힙이어야 한다!!

- 노드 삭제

  - 루트에서 항목을 삭제하면 된다.
  - 그 후, 힙(트리)의 마지막 항목을 복사하고 이 마지막 항목을 삭제한다.
  - 다시 트리를 힙으로 만들기 위해 percolate down 함수를 호출한다. 

### 그래서...

```
우선순위 큐를 힙으로 구현하면 연산에
- 검색, 삽입, 삭제에 O(log n) 
- 최솟값, 최댓값 찾기에 O(1)
이 소요!!!
```

![IMG_3051](readme.assets/IMG_3051.JPG)



### 다익스트라 알고리즘

- 다익스트라 알고리즘은 BFS 알고리즘을 일반화한 것이다.
- 보통의 BFS 알고리즘은 큐의 가장 앞에 있는 정점이 시작점 s와 weight를 고려한 제일 가까운 점이라는 것을 보장할 수 없기 때문에 weighted 그래프의 최단 경로 문제를 풀 수 없다.
- 우선순위 큐를 사용한다.



### MST(최소비용 신장 트리, Undirected, Weighted 그래프)

- 어떤 그래프의 spanning tree는 모든 정점을 포함하고 있는 sub-graph 이면서 또한 tree이다. => 사이클이 없다.
- 크림 Kream
- 크루스칼 Kruskal





# 알고리즘

|BOOK| 파이썬 알고리즘 인터뷰 

|VOD| 공학 >컴퓨터ㆍ통신 >컴퓨터공학 | [알고리즘] 건국대학교 김강일

### 개요

- 알고리즘의 효율성
  - Time complexity : computation time  -> Asymptotic Notation(Big-O notation, n 이 무한대로 갈 때 upperbound 를 구한다.) 사용
  - Space complexity : memory

### Divide and Conquer(0424)

- Divide + Conquer 2스텝으로 구성
- N이 너무 커서 오래걸릴 때 N/2로 나눈다. input size를 나눈다.
- 예시
  - quick sort
  - binary search
  - selection
  - insertion sort
  - merge sort
- **Merge Sort** : 구현이 까다롭다. 깔끔한 Divide and Conquer
  - a = 2, b = 2
  - Divide : N/2 개씩 넣으면 끝, 각 그룹이 number를 1개 가질때 까지 나눈다.
  - Conquer : 제일 작은 subproblem 을 계산하고, 2일 경우 비교연산을 수행한다. 하지만 이 과정에서 다시 sorting 이 들어가야 하고, 비교연산이 이루어져야 한다.
- Quick Sort
- Insertion Sort

### Greedy(0516)

- 그리디로 풀 수 있는 문제?
- MST
  - 부분 신장 그래프란 : 그래프가 가진 꼭짓점을 모두 포함하면서 그래프의 변으로 그려진 그래프
  - 최소 신장 트리 : 그래프의 모든 꼭짓점을 노드로 포함하면서 노드 간의 비용을 최소로 하는 트리
- KruskalMST(G)
  - Input: a weighted graph
  - Output: mininum spanning tree T
  - 노드가 n개, 엣지가 m개인 그래프라면 엣지의 갯수 - 1 이 노드의 갯수 일 때 까지만 돌린다. 노드가 n 개일 때 최대 엣지 수는 n-1 개이기 때문!

### 그리디 문제정리

- Coin Change
- MST
- Shortest Path

- Fractional Knapsack 

- Set Covering 
  - City Planning
  - CCTV로 복도 커버하기
  - 바이러스 커버하는 substring 찾기
  - Subcontractor Selection to Build a Car
  - Employment to Cover All Required Works with Minimim Number of Employee
- Task Scheduling / Job Scheduling
  - starting time-ending time
  - task length
  - 순서 : 1. earilest start time!! 으로 sorting()

### Dynamic Programming(0426)

- divide and conquer 보다 범용적이다. 가장 큰 차이는 'Memorization' 이다.
- subproblem 을 저장해서 재사용하는 것이 포인트이다!
- 언제 사용하나?
  - merge path 가 복잡할 때
  - subproblem 이 반복될 때
- n개의 노드에서 출발하는 가장 짧은 경로를 구하자..
  - 다익스트라 알고리즘 : 모든 starting point에서 shortest path를 단계적으로 찾는다
  - DP 적으로 풀어보자 => Floyd-Warshall Algorithm
- 어떤 정보를 memorize 해야 할까?
  - 

### Approximation

### Search



